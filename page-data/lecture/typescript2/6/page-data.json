{
    "componentChunkName": "component---src-components-lecture-page-layout-js",
    "path": "/lecture/typescript2/6",
    "result": {"data":{"mdx":{"id":"28c18dc7-48d3-5fc7-ab9f-f2e8246f272e","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Typescript Besonderheiten\",\n  \"date\": \"2021-11-22T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Besonderheiten von JavaScript\"), mdx(\"p\", null, \"Prototypbasierte Sprache (klassenlose Objektorientierung):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objekte werden durch Klonen anderer Objekte erstellt (nicht durch das instanziieren von Klassen)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objektorientiert, aber nicht Klassenbasiert (keine Klassen als Vorlagen)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Alle Objekte eines Typs beinhalten Referenz auf das gleiche Prototyp Objekt\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objekte k\\xF6nnen zur Laufzeit erweitert werden\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model\"\n  }, \"mehr Informationen\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"class Test {}\\nclass Test2 extends Test {}\\nlet t: Test2 = new Test2();\\nconsole.log(t); // auf Konsole betrachten\\n\")), mdx(\"p\", null, \"Unterst\\xFCtzt funktionalen Programmieransatz:\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-java-funktional\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-java-funktional\",\n    \"className\": \"footnote-ref\"\n  }, \"java-funktional\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Funktionen in Variablen speicherbar (mit Funktionsausdruck oder Pfeilfunktion) = \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developer.mozilla.org/de/docs/Glossary/First-class_Function\"\n  }, \"Funktion erster Klasse\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Funktionen h\\xF6herer Ordnung (hat Funktion als \\xDCbergabeparameter und/oder R\\xFCckgabewert)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Typdefinition f\\xFCr Funktion orientiert sich in TypeScript an Pfeilfunktion\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Funktionsausdruck\\nlet plusOne = function (n: number): number {\\n  return n + 1;\\n};\\n\\n// Pfeilfunktion Schreibweise\\nlet minusOne = (n: number): number => {\\n  return n - 1;\\n};\\n\\nconsole.log(plusOne(10));\\nconsole.log(minusOne(10));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function plusOne(n: number): number {\\n  return n + 1;\\n}\\n\\n// Typdefinition f\\xFCr a: (n: number) => number\\nlet a: (n: number) => number = plusOne;\\n\\nfunction b(f: (n: number) => number): number {\\n  return f(5);\\n}\\n\\nconsole.log(b(a));\\n\")), mdx(\"h1\", null, \"Array\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"length ver\\xE4nderbar\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let a: number[] = [1, 2, 3];\\nconsole.log(a);\\na.length = 2;\\nconsole.log(a);\\na.length = 4;\\nconsole.log(a);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"besitzt \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.w3schools.com/jsref/jsref_obj_array.asp\"\n  }, \"verschiedene Methoden\"), \":\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elemente hinzuf\\xFCgen oder wegnehmen: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"push\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"pop\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Suche von Elementen im Array: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"includes\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"indexOf\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Alle Elemente zu String verbinden: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"join\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Funktionen auf jedes Element anwenden: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"forEach\"))))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let fruits: string[] = [\\\"Birne\\\"];\\nfruits.push(\\\"Apfel\\\");\\nfruits.push(\\\"Banane\\\");\\nconsole.log(fruits);\\nconsole.log(fruits.join(\\\" + \\\"));\\nconsole.log(fruits.indexOf(\\\"Banane\\\"));\\nconsole.log(fruits.pop());\\nconsole.log(fruits.includes(\\\"Banane\\\"));\\nlet fruits2: string[] = fruits.map(function (fruit: string): string {\\n  return `1x ${fruit}`;\\n});\\nfruits2.forEach(function (fruit: string): void {\\n  console.log(fruit);\\n});\\n\")), mdx(\"h3\", null, \"Rest Operator\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mit \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"...\"), \" beliebig viele weitere Parameter in Array zusammenfassen\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Funktion die mindestens einen Vornamen verlangt\\nfunction countFirstNames(\\n  firstName1: string,\\n  ...moreFirstNames: string[]\\n): number {\\n  return moreFirstNames.length + 1;\\n}\\n\\nconsole.log(countFirstNames(\\\"Max\\\"));\\nconsole.log(countFirstNames(\\\"Max\\\", \\\"Moritz\\\"));\\n// countFirstNames(); // Fehler in TypeScript Code!\\n\")), mdx(\"h3\", null, \"Strings\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"besitzen ebenfalls \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.w3schools.com/jsref/jsref_obj_string.asp\"\n  }, \"verschiedene Methoden\"))), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let s: string = \\\"Test\\\";\\nconsole.log(s.charAt(0));\\nconsole.log(s.includes(\\\"es\\\"));\\nconsole.log(s.length);\\nconsole.log(s.substring(1, 2));\\n\")), mdx(\"h1\", null, \"Objekt\"), mdx(\"p\", null, \"verschiedene Schreibweisen zum Zugriff auf Eigenschaften:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Punktnotation: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"objektName.eigenschaft\"), \" (eigenschaft = Zahlen, Buchstaben, \", \"_\", \", $ und darf nicht mit Zahl beginnen)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Klammernotation: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"objektName[\\\"eigenschaft\\\"]\"), \" (eigenschaft beliebiger String)\")), mdx(\"h3\", null, \"Kurzschreibweise Konstruktor\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attribute k\\xF6nnen direkt im Konstruktor angelegt werden, wenn private/public/protected vor die Parameter geschrieben wird\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"diese werden dann automatisch gesetzt (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"this.firstName = firstName\"), \" kann weggelassen werden)\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"class Person {\\n  constructor(private firstName: string, private lastName: string) {}\\n  print(): string {\\n    return `Person: ${this[\\\"firstName\\\"]} ${this.lastName}`; // beide Schreibweisen erlaubt\\n  }\\n}\\n\\nlet p: Person = new Person(\\\"Max\\\", \\\"Mustermann\\\");\\nconsole.log(p.print());\\n\")), mdx(\"h3\", null, \"Getter / Setter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Methoden mit get und set davor k\\xF6nnen wie Attribute verwendet werden (ohne Funktionsaufruf)\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"class Person {\\n  constructor(\\n    private firstName: string,\\n    private lastName: string,\\n    private age = 0\\n  ) {}\\n  set currentAge(newAge: number) {\\n    if (newAge > this.age) {\\n      this.age = newAge;\\n    }\\n  }\\n  get currentAge(): number {\\n    return this.age;\\n  }\\n  get fullName(): string {\\n    return `${this.firstName} ${this.lastName}`;\\n  }\\n}\\n\\nlet p: Person = new Person(\\\"Max\\\", \\\"Mustermann\\\");\\np.currentAge = 25;\\np.currentAge = 20;\\nconsole.log(p.currentAge);\\nconsole.log(p.fullName);\\n\")), mdx(\"h1\", null, \"Objekt Typen\"), mdx(\"p\", null, \"Typen definieren ohne eine Klasse anzulegen (ohne Defaultwerte und Funktionalit\\xE4t)\"), mdx(\"h3\", null, \"Interface\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"wie in Java ein Vertrag, den das Objekt erf\\xFCllen muss, welches das Interface implementiert\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"festlegen beliebiger Eigenschaften (Variablen und Methoden)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"zur Definition eigener Typen\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"implements\"), \" um sicher zu stellen, dass eine Klasse das Interface erf\\xFCllt (wie bei Java)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Vererbung auch zwischen Interfaces m\\xF6glich (Interface1 \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"extends\"), \" InterfaceBasic)\")), mdx(\"p\", null, \"=> Interface ist Klasse vorzuziehen, wenn es nur um die Festlegung des Typs geht\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"diese werden nur f\\xFCr den Typcheck von TypeScript verwendet und verschwinden beim kompilieren nach JavaScript (schlankerer Code)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Verwendungszweck zum Beispiel um die Struktur von Daten zu beschreiben, die vom Server kommen\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string;\\n  lastName: string;\\n}\\n\\nfunction printName(name: Name): string {\\n  return `${name.firstName} ${name.lastName}`;\\n}\\n\\nlet neuerName: Name = { firstName: \\\"Max\\\", lastName: \\\"Mustermann\\\" }; // Objekte direkt mit Werten anlegen\\nconsole.log(printName(neuerName));\\n\")), mdx(\"h3\", null, \"Anonyme Typen\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objekttypen anstelle von Typbezeichner direkt definieren\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function printName(name: { firstName: string; lastName: string }): string {\\n  return `${name.firstName} ${name.lastName}`;\\n}\\n\\nconsole.log(printName({ firstName: \\\"Max\\\", lastName: \\\"Mustermann\\\" }));\\n\")), mdx(\"h3\", null, \"union type, typeof\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mehrere Typen als zul\\xE4ssig definieren\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mit Oderstrichen getrennt auflisten (Datentyp1 | Datentyp2 | Datentyp3)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mit \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"typeof\"), \" auf Typ pr\\xFCfen\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string | string[];\\n  lastName: string;\\n}\\n\\nfunction printName(name: Name): string {\\n  if (typeof name.firstName === \\\"string\\\") {\\n    return `${name.firstName} ${name.lastName}`;\\n  } else {\\n    return `${name.firstName.join(\\\" \\\")} ${name.lastName}`;\\n  }\\n}\\n\\nconsole.log(\\n  printName({ firstName: [\\\"Max\\\", \\\"Moritz\\\"], lastName: \\\"Mustermann\\\" })\\n);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"auch direkt mit Werten als Typangabe m\\xF6glich\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"class Person {\\n  constructor(private firstName: string, private lastName: string) {}\\n  printName(nameType: \\\"first\\\" | \\\"last\\\"): string {\\n    return this[`${nameType}Name`];\\n  }\\n}\\n\\nlet p: Person = new Person(\\\"Max\\\", \\\"Mustermann\\\");\\nconsole.log(p.printName(\\\"last\\\"));\\n\")), mdx(\"h3\", null, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases\"\n  }, \"Type Aliases\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Typen einen Namen geben\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"type FirstName = string | string[];\\n\\ninterface Name {\\n  firstName: FirstName;\\n  lastName: string;\\n}\\n\\ntype AuchName = Name;\\n\\nlet max: AuchName = { firstName: [\\\"Max\\\", \\\"Moritz\\\"], lastName: \\\"Mustermann\\\" };\\n\")), mdx(\"h3\", null, \"Beispiel f\\xFCr Fortgeschrittene\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string;\\n  lastName: string;\\n}\\n\\nfunction hello(name: Name): PrintObject {\\n  return {\\n    toString: function (): string {\\n      return `Hallo, mein Name ist ${name.firstName} ${name.lastName}`;\\n    },\\n  };\\n}\\n\\nlet printObj: PrintObject = hello({ firstName: \\\"Max\\\", lastName: \\\"Mustermann\\\" });\\nconsole.log(printObj.toString());\\n\\ninterface PrintObject {\\n  toString(): string;\\n}\\n\\nfunction printer(o: PrintObject): void {\\n  console.log(o.toString());\\n}\\n\\nprinter(hello({ firstName: \\\"Max\\\", lastName: \\\"Mustermann\\\" }));\\n\\nclass Person implements Name, PrintObject {\\n  constructor(public firstName: string, public lastName: string) {}\\n  toString(): string {\\n    return `Person: ${this.firstName} ${this.lastName}`;\\n  }\\n}\\n\\nprinter(new Person(\\\"Max\\\", \\\"Mustermann\\\"));\\n\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://javascript.plainenglish.io/when-to-best-use-type-class-or-interface-in-typescript-73bf66de19e9\"\n  }, \"Wann was benutzen\")), mdx(\"h1\", null, \"Fragezeichen\"), mdx(\"h3\", null, \"undefined, null\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"beschreibt das Fehlen eines Wertes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \": Variable wurde noch kein Wert zugewiesen (wird automatisch gesetzt, wenn kein Wert zugewiesen wird)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null\"), \": Variable wurde explizit auf \\\"kein Wert gesetzt\\\" (selbst zuweisen mit \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"= null\"), \")\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let x: number;\\nlet y: string = null;\\n// let y: string | null = null // mit strictTypeChecks in tsconfig\\n\\nconsole.log(x); // TypeScript warnt hier vor einem Fehler\\nconsole.log(y);\\n\")), mdx(\"h3\", null, \"Optionale Parameter\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\xDCbergabeparameter oder Eigenschaft in Typdefinition (Klasse, Interface, Type), als optional definieren\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dieser Parameter kann, muss aber nicht angegeben werden\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Wird durch ein \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"?\"), \" am Ende des Variablennamens gekennzeichnet\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function printName(firstName: string, lastName?: string): string {\\n  if (lastName !== undefined) {\\n    return `${firstName} ${lastName}`;\\n  } else {\\n    return `${firstName}`;\\n  }\\n}\\n\\nconsole.log(printName(\\\"Max\\\", \\\"Mustermann\\\"));\\nconsole.log(printName(\\\"Moritz\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string;\\n  lastName?: string;\\n}\\n\\nlet p1: Name = { firstName: \\\"Max\\\", lastName: \\\"Mustermann\\\" };\\nlet p2: Name = { firstName: \\\"Moritz\\\" };\\n\")), mdx(\"h3\", null, \"Optionale Verkettung\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"sch\\xFCtzt vor dem Zugriff auf undefinierte Variablen\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"greift nur zu, wenn die Variable nicht \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \" oder \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null\"), \" ist (w\\xFCrde sonst Fehler werfen)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ein \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"?\"), \" hinter dem Variablennamen vor dem Punktzugriff\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"gibt \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), \" zur\\xFCck, wenn kein Zugriff m\\xF6glich ist\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function initials(firstName: string, lastName?: string): string {\\n  return `${firstName.charAt(0)}${lastName?.charAt(0) || \\\"\\\"}`;\\n}\\n\\nconsole.log(initials(\\\"Max\\\", \\\"Mustermann\\\"));\\nconsole.log(initials(\\\"Moritz\\\"));\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string;\\n  lastName?: string;\\n}\\nlet p3: Person;\\nconsole.log(p3?.firstName);\\n\")), mdx(\"h1\", null, \"Destrukturierung\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Mehrere Attribute k\\xF6nnen auf einmal aus einem Objekt extrahiert werden\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Name {\\n  firstName: string;\\n  lastName: string;\\n}\\n\\nclass Person {\\n  constructor(\\n    public firstName: string,\\n    public lastName: string,\\n    public age: number\\n  ) {}\\n}\\n\\nlet p: Person = new Person(\\\"Max\\\", \\\"Mustermann\\\", 25);\\nlet { firstName, lastName }: Name = p;\\nconsole.log(`${firstName} ${lastName}.`);\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Funktioniert auch f\\xFCr Arrays:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"let a: number[] = [1, 2, 3];\\nlet [a0, a1, a2, a3]: number[] = a;\\nconsole.log(`${a0}, ${a1}, ${a2}, ${a3}`);\\n\")), mdx(\"h1\", null, \"namespace\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Variablennamen (bzw. Funktionsnamen) einmalig in Namensraum\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Globaler Namensraum, wenn kein Namensraum angegeben ist\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Eigenen Namensraum festlegen mit \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"namespace NamensraumName { //Code }\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Namensr\\xE4ume mit gleichem Namen werden zusammengefasst\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Um eine Variable (bzw. Funktion) au\\xDFerhalb des Namensraum zugreifbar zu machen \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"export\"), \" davor schreiben (Zugriff \\xFCber \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"NamensraumName.VariablenName\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Namensr\\xE4ume geben dem Projekt mehr Struktur und verhindern Namenskonflikte\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"namespace Test1 {\\n  let x: number = 1;\\n  export let y: string = \\\"a\\\";\\n}\\n\\nnamespace Test2 {\\n  let x: number = 2;\\n  let y: number = 3;\\n  console.log(Test1.y);\\n  console.log(y);\\n}\\n\")), mdx(\"h1\", null, \"Linksammlung\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.typescriptlang.org/docs/handbook\"\n  }, \"https://www.typescriptlang.org/docs/handbook\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.tutorialsteacher.com/typescript\"\n  }, \"https://www.tutorialsteacher.com/typescript\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learning.oreilly.com/library/view/mastering-typescript-/9781800564732/?ar=#toc\"\n  }, \"https://learning.oreilly.com/library/view/mastering-typescript-/9781800564732/?ar=#toc\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://learning.oreilly.com/library/view/essential-typescript-4/9781484270110/?ar#toc\"\n  }, \"https://learning.oreilly.com/library/view/essential-typescript-4/9781484270110/?ar#toc\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://instil.co/blog/typescript-43-objects/\"\n  }, \"https://instil.co/blog/typescript-43-objects/\")), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-java-funktional\"\n  }, \"Auch Java erlaubt seit Java 8 funktionale Programmierung, siehe \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://openbook.rheinwerk-verlag.de/javainsel/11_006.html\"\n  }, \"https://openbook.rheinwerk-verlag.de/javainsel/11_006.html\"), mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-java-funktional\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Typescript Besonderheiten","date":"22 November, 2021"}}},"pageContext":{"id":"28c18dc7-48d3-5fc7-ab9f-f2e8246f272e","heading":{"value":"Destrukturierung","depth":1},"index":6,"prevSlug":"/lecture/typescript2/5","nextSlug":"/lecture/typescript2/7"}},
    "staticQueryHashes": ["170874137"]}